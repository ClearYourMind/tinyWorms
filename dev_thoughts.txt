16/09/2025
55698e4

Доступ к кадрам организован через двойные ссылки. Анимации (anim_stand_r, ...) ссылаются на массив кадров (frame_list в модуле frames.c) в котором хранятся ссылки на кадры.
При наличии массива кадров проблематично сохранить последовательное именование в случае когда нужно добавить кадры посреди анимации.
Имена кадров соответствуют их индексам в массиве frame_list.

Может возможно указывать в анимациях непосредственно кадры? (frame_A...)

Массивы с кадрами и анимациями (frame_A... и anim_stand_,,) записаны через PROGMEM, чтобы из них составить двумерный массив где второе измерение имеет переменную длину.

Может можно сделать массив с указателями на эти массивы с переменной длиной?


18/09/2025

Посмотреть можно ли переделать функции Sprites.drawOverwrite, drawSelfMasked... чтобы использовали для отрисовки спрайт не из программной области памяти (PROGMEM / pgm_read_byte_near), а из оперативной.
Так можно будет создавать спрайты динамически, использовать эффекты маски, например, рендерив их в экранный буфер.


26/10/2025
ae0e1ca

Обнаружена ситуация, когда игрок может пролезть в щель высотой в одну ячейку. 
 #
O O
O #
O #
Если игрок приземлится в таком месте, то сможет идти вперед. Хотя приземляться при такой комбинации ячеек не должен.
Исправил движение вперед в таком случае. Но всё же остается возможным приземляться на отвесную стену..


08/11/2025

Надо бы генерировать ландшафт, а не хранить его весь в оперативке или в формате спрайта. Мы же будем идти постоянно вперед.. 
Нужны хотя бы 4 экрана сгенерированной карты и дальше генерировать ее экранами по мере продвижения камеры.
---------
| 1 | 2 |
---------
| 3 | 4 |
---------
Придумал алгоритм где снизу вверх строятся ground bubbles, а сверху вниз - sky bubbles постепенно уменьшаясь в диаметре. Sky bubbles отъедают землю (ground bubbles). Так можно получить возвышающиеся выпуклые структуры, а не плоский ландшафт как с помощью алгоритма midpoint displacement.

Но сначала надо добавить анимации и стрельбу с разрушаемостью. Кстати по мере разрушения земли неплохо было бы обнаруживать висячие острова, чтобы они осыпались.


11/11/2025

Код чтения клавиш участвует в коде управлении игроком и в коде переключения анимаций. Еще код управления будет другим у игроков управляемых ии.
Нужно сделать код управления заменяемым и переиспользуемым. Выделить в класс (?). Передавать триггеры управления игроку через флаги и использовать их в коде анимации (?)


16/11/2025
dev
Указатели увеличивают скомпилированный код. Попробовал передавать .._flags по указателю и менять внутри setFlagAsBool(). Код получается больше, чем просто возвращать измененное значение и присваивать его переменной .._flags.


22/11/2025

Похоже anim_flags можно не использовать и вместо processAnim лучше добавить switchAnim(AN_WALK) например, а внутри уже выбирать какую именно анимацию включить в зависимости от конфигурации cells


06/12/2025

Получилось выделить класс Player в отдельный модуль Player.h с помощью DeepSeek. Похоже необходимо сделать общий  модуль Common.h потому, что сейчас меняю field=[] чтобы он содержал несколько экранов и это объявление дублируется в нескольких модулях


22/12/2025

Думаю надо оставить замкнутую сцену в 2 на 2 экрана и генерировать ландшафт после каждого уровня (?). Наверное проблемно будет генерировать каждый новый экран впереди бесшовно...


28/12/2025

..да и переменные координат камеры и игрока быстро увеличиваются, не умещаются в 16 бит учитывая, что 8 битов числа используется как дробная часть!
Пробую сделать возможным бесконечное перемещение игрока и камеры право


16/01/2026

Обнаружена проблема, когда вершины сливаются в координатах x/y совпадающих с центром. Понял почему: в scTab вместо чистой единицы (1.0f , 256) используетcя (0.99f, 255). При отрисовке дробная часть отбрасывается, 0.00 и 0.99 оказываются равными.

Что делать?
 - 16 битные sin, cos в scTab и 256 вместо 255 + перемножение целой и дробной части поотдельности, чтобы не было переполнения.
 - учет особых случаев для sin и cos равных 0 и 255 в transform_vertex (использование разных формул для этих случаев)		(ветвление алгоритма во много раз вызывающейся в цикле функции)
 - FBITS = 4 вместо 8 и scTab[.., 256 >> 4 (1 << FBITS)] вместо 255. 	(норм вариант, но во многих местах появляются баги (с фокусом камеры например))
 - Верное округление при приведении к целому числу, а не просто отбрасывание дробной части.		(придется использовать функцию ftoint вместо простого смещения)

